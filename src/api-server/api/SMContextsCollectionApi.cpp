/**
 * Nsmf_PDUSession
 * SMF PDU Session Service. Â© 2019, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0.alpha-1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The OpenAirInterface Software Alliance licenses this file to You under
 * the OAI Public License, Version 1.1  (the "License"); you may not use this file
 * except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.openairinterface.org/?page_id=698
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *-------------------------------------------------------------------------------
 * For more information about the OpenAirInterface (OAI) Software Alliance:
 *      contact@openairinterface.org
 */

#include "SMContextsCollectionApi.h"
#include "logger.hpp"
#include "Helpers.h"
extern "C" {
#include "multipartparser.h"
}

#include <cassert>
#include <cstring>
#include <cstdio>
#include <iostream>
#include <list>
#include <map>
#include <string>

#define BOUNDARY "----Boundary"

typedef struct part {
	std::map<std::string,std::string> headers;
	std::string body;
} part;

static multipartparser_callbacks g_callbacks;

static bool             g_body_begin_called;
static std::string      g_header_name;
static std::string      g_header_value;
static std::list<part>  g_parts;
static bool             g_body_end_called;

static void init_globals()
{
	g_body_begin_called = false;
	g_header_name.clear();
	g_header_value.clear();
	g_parts.clear();
	g_body_end_called = false;
}

static int on_body_begin(multipartparser* /*parser*/)
{
	g_body_begin_called = true;
	return 0;
}

static int on_part_begin(multipartparser* /*parser*/)
{
	g_parts.push_back(part());
	return 0;
}

static void on_header_done()
{
	g_parts.back().headers[g_header_name] = g_header_value;
	g_header_name.clear();
	g_header_value.clear();
}

static int on_header_field(multipartparser* /*parser*/, const char* data, size_t size)
{
	if (g_header_value.size() > 0)
		on_header_done();
	g_header_name.append(data, size);
	return 0;
}

static int on_header_value(multipartparser* /*parser*/, const char* data, size_t size)
{
	g_header_value.append(data, size);
	return 0;
}

static int on_headers_complete(multipartparser* /*parser*/)
{
	if (g_header_value.size() > 0)
		on_header_done();
	return 0;
}

static int on_data(multipartparser* /*parser*/, const char* data, size_t size)
{
	g_parts.back().body.append(data, size);
	return 0;
}

static int on_part_end(multipartparser* /*parser*/)
{
	return 0;
}

static int on_body_end(multipartparser* /*parser*/)
{
	g_body_end_called = true;
	return 0;
}


namespace oai {
namespace smf_server {
namespace api {

using namespace oai::smf_server::helpers;
using namespace oai::smf_server::model;

SMContextsCollectionApi::SMContextsCollectionApi(std::shared_ptr<Pistache::Rest::Router> rtr) { 
	router = rtr;
}

void SMContextsCollectionApi::init() {
	setupRoutes();
}

void SMContextsCollectionApi::setupRoutes() {
	using namespace Pistache::Rest;

	Routes::Post(*router, base + "/sm-contexts", Routes::bind(&SMContextsCollectionApi::post_sm_contexts_handler, this));

	// Default handler, called when a route is not found
	router->addCustomHandler(Routes::bind(&SMContextsCollectionApi::sm_contexts_collection_api_default_handler, this));
}

void SMContextsCollectionApi::post_sm_contexts_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {

	Logger::smf_api_server().info("Received a SM context create request from AMF");
	Logger::smf_api_server().debug("Request body: %s\n",request.body().c_str());
	SmContextMessage smContextMessage;
	SmContextCreateData smContextCreateData;

	//step 1. use multipartparser to decode the request
	multipartparser_callbacks_init(&g_callbacks);
	g_callbacks.on_body_begin = &on_body_begin;
	g_callbacks.on_part_begin = &on_part_begin;
	g_callbacks.on_header_field = &on_header_field;
	g_callbacks.on_header_value = &on_header_value;
	g_callbacks.on_headers_complete = &on_headers_complete;
	g_callbacks.on_data = &on_data;
	g_callbacks.on_part_end = &on_part_end;
	g_callbacks.on_body_end = &on_body_end;

	multipartparser parser;
	init_globals();
	multipartparser_init(&parser, BOUNDARY);
	if ((multipartparser_execute(&parser, &g_callbacks, request.body().c_str(), strlen(request.body().c_str())) != strlen(request.body().c_str())) or (!g_body_begin_called)){
		response.send(Pistache::Http::Code::Bad_Request, "");
		return;
	}

	//at least 2 parts for Json data and N1 (+ N2)
	if (g_parts.size() < 2){
		response.send(Pistache::Http::Code::Bad_Request, "");
		return;
	}
	part p0 = g_parts.front(); g_parts.pop_front();
	Logger::smf_api_server().debug("Request body, part 1: \n%s", p0.body.c_str());
	part p1 = g_parts.front(); g_parts.pop_front();
	Logger::smf_api_server().debug("Request body, part 2: \n %s",p1.body.c_str());
	if (g_parts.size() == 3) {
		part p2 = g_parts.front(); g_parts.pop_front();
		Logger::smf_api_server().debug("Request body, part 3: \n %s",p2.body.c_str());
	}

	//step 2. process the request
	try {
		nlohmann::json::parse(p0.body.c_str()).get_to(smContextCreateData);
		smContextMessage.setJsonData(smContextCreateData);
		smContextMessage.setBinaryDataN1SmMessage(p1.body.c_str());
		this->post_sm_contexts(smContextMessage, response);
	} catch (nlohmann::detail::exception &e) {
		//send a 400 error
		response.send(Pistache::Http::Code::Bad_Request, e.what());
		return;
	} catch (std::exception &e) {
		//send a 500 error
		response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
		return;
	}

}

void SMContextsCollectionApi::sm_contexts_collection_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
	response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

}
}
}

